pub fn execute_ir(code: &str) {
    let tokens = lex_ir(code);
    let bytecode = match parse_ir(&tokens, &mut 0) {
    Ok(bytecode) => {
        println!("Valid IR. Executing Generated Bytecode...");
        bytecode
    }

    Err(e) => {
        println!("***Error. Invalid Bytecode.");
        println!("------------------");
        for (i, l) in code.lines().enumerate() {
            println!("{:03}:  {}", i+1, l);
            if i+1 == e.line {
                break;
            }
        }
        println!("------------------");
        println!("{e}");
        return;
    }

    };

    let stdin = io::stdin();
    run_program(&stdin, &bytecode);
}

use std::io;

fn lex_ir(mut code: &str) -> Vec<IRTok> {
    let mut tokens: Vec<IRTok> = vec![];
    while code.len() > 0 {
        let (tok, rest) = lex_ir_token(code);
        match tok {
        None => break,
        Some(value) => tokens.push(value),
        }
        code = rest;
    }

    return tokens;
}

const MAX_LINE: usize = 2000000;

fn parse_ir(tokens: &Vec<IRTok>, idx: &mut usize) -> Result< Vec<FunctionBytecode>, IRError> {
    let mut serialized_line: usize = 1;
    let mut vector: Vec<FunctionBytecode> = vec![];
    let mut has_main: bool = false;
    while let Some(bytecode) = parse_func_ir(&mut serialized_line, tokens, idx)? {
        for func in &vector {
          if func.name.eq(&bytecode.name) {
            return error(MAX_LINE, format!("Error. Two functions with the same name {}", func.name));
          }
        }
        if bytecode.name.eq("main") {
          has_main = true;
        }
        vector.push(bytecode);
    }

    if has_main == false {
      return error(MAX_LINE, format!("Error. Generated code does not have a main."));
    }

    // todo: this is not the correct line numbers. but I dunno how to get better line numbers...
    for func_id in 0..vector.len() {
        for instr_id in 0..vector[func_id].body.len() {
            if let Bytecode::Call(r, call, params) = &vector[func_id].body[instr_id] {
                if let IRTok::Var(func_name) = &tokens[*call] {
                    if let Some(call_value) = find_func_id(&vector, func_name) {
                         if params.len() != vector[call_value].parameters {
                             return error(MAX_LINE, format!("Error. Invalid parameter passing to '{func_name}'. Expected {} number of parameters. Got {} number of parameters.", vector[call_value].parameters, params.len()));
                         }
                         vector[func_id].body[instr_id] = Bytecode::Call(*r, call_value, params.to_vec());
                    } else {
                         return error(MAX_LINE, format!("Error. Undeclared function '{}'", func_name));
                    }
                } else {
                    return error(MAX_LINE, format!("Internal Interpreter Error."));
                }
            }
        }
    }

    return Ok(vector);

    fn find_func_id(v: &Vec<FunctionBytecode>, func_name: &str) -> Option<usize> {
        for (i, function) in v.iter().enumerate() {
            if function.name.eq(func_name) {
                return Some(i);
            }
        }
        return None;
    }
}

struct IRError {
    line: usize,
    message: String,
}

impl fmt::Display for IRError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.line == MAX_LINE {
            write!(f, "Error. {}", self.message)
        } else {
            write!(f, "Error at line {}. {}", self.line, self.message)
        }
    }
}

fn error<T>(line: usize, message: String) -> Result<T, IRError> {
    Err(IRError {line: line, message: message})
}

use std::fmt;

fn parse_func_ir(serialized_line: &mut usize, tokens: &Vec<IRTok>, idx: &mut usize) -> Result<Option<FunctionBytecode>, IRError> {
    let mut function_bytecode = FunctionBytecode {
        name:String::from(""),
        parameters:0,
        id:0,
        variables: HashMap::new(),
        body: vec![],
    };

    loop {
        if let Some(IRTok::EndInstr) = peek(tokens, *idx) {
             *serialized_line += 1;
             *idx += 1;
             continue;
        }

        break;
    }

    match next(tokens, idx) {
    Some(token) => {
        if !matches!(token, IRTok::Func) {
            return error(*serialized_line, format!("func IR must begin with '%func'"));
        }
    }
 
    None => {
        return Ok(None);
    }
    }
    match next_result(*serialized_line, tokens, idx)? {
    IRTok::Var(func_ident) => {
        function_bytecode.name = func_ident.clone();
    }

    _ => return error(*serialized_line, String::from("func IR must have an identifier name such as '%func main'")),

    };

    match peek_result(*serialized_line, tokens, *idx)? {
    IRTok::LParen => {
        *idx += 1;
        loop {
            match next_result(*serialized_line, tokens, idx)? {
            IRTok::RParen => break,
            IRTok::Int => {
                match next_result(*serialized_line, tokens, idx)? {
                IRTok::Var(param) => {
                    if let Some(_) = function_bytecode.variables.get(param) {
                        let f = format!("identifier {param} already defined");
                        return error(*serialized_line, f);
                    } else {
                        function_bytecode.parameters += 1;
                        let id = get_id(&mut function_bytecode);
                        function_bytecode.variables.insert(param.clone(), VariableType::IntVar(id));
                    }
                    if matches!(peek_result(*serialized_line, tokens, *idx)?, IRTok::Comma) {
                        *idx += 1;
                    }
                }
                _ => {
                    return error(*serialized_line, String::from("invalid parameters format for functions"));
                }
                }
            }
            _ => {
                return error(*serialized_line, String::from("invalid parameters format for functions"));
            }

            }
        }
    }
    _ => {}

    }

    if !matches!(next_result(*serialized_line, tokens, idx)?, IRTok::EndInstr) {
        return error(*serialized_line, String::from("%func header must end with a newline"));
    }

    *serialized_line += 1;

    let mut labels_hash: HashMap<String, usize> = Default::default();
    let mut line: usize = 0;
    loop {
        let bytecode = parse_instruction(serialized_line, line, &mut function_bytecode, &mut labels_hash, tokens, idx)?;
        if matches!(bytecode, Bytecode::End) {
            break;
        }
        function_bytecode.body.push(bytecode); 
        line += 1;
    }

    if !matches!(next_result(*serialized_line, tokens, idx)?, IRTok::EndFunc) {
        return error(*serialized_line, String::from("func IR needs to end in '%endfunc'"));
    }

    function_bytecode.body.push(Bytecode::End); 
    for i in 0..function_bytecode.body.len() {
        match &function_bytecode.body[i] {
        Bytecode::Jmp(index) => {
            if let IRTok::Label(label_name) = &tokens[*index] {
                if let Some(id) = labels_hash.get(label_name) {
                    function_bytecode.body[i] = Bytecode::Jmp(*id);
                } else {
                    return error(i, format!("Error. invalid label {}", label_name));
                }
            } else {
                return error(*serialized_line, String::from("Internal Compiler Error."));
            }
        }
        Bytecode::BranchIf(tf, index) => {
            if let IRTok::Label(label_name) = &tokens[*index] {
                if let Some(id) = labels_hash.get(label_name) {
                    function_bytecode.body[i] = Bytecode::BranchIf(tf.clone(), *id);
                } else {
                    return error(*serialized_line, format!("Error. invalid label {}", label_name));
                }
            } else {
                return error(*serialized_line, String::from("Internal Compiler Error."));
            }
        }
        Bytecode::BranchIfn(tf, index) => {
            if let IRTok::Label(label_name) = &tokens[*index] {
                if let Some(id) = labels_hash.get(label_name) {
                    function_bytecode.body[i] = Bytecode::BranchIfn(tf.clone(), *id);
                } else {
                    return error(*serialized_line, format!("Error. invalid label {}", label_name));
                }
            } else {
                return error(*serialized_line, String::from("Internal Compiler Error."));
            }
        }
        _ => {}
        }
    }
    return Ok(Some(function_bytecode));
}

use std::collections::HashMap;

struct FunctionBytecode {
    name: String,
    parameters: usize,
    id: i32,
    variables: HashMap<String, VariableType>,
    body: Vec<Bytecode>,
}

fn get_id(function: &mut FunctionBytecode) -> i32 {
    let id = function.id;
    function.id += 1;
    id
}

fn read_integer_value(variables: &HashMap<i32, i32>, op: &Op) -> i32 {
    match op {
    Op::Num(num) => *num,
    Op::Var(id) => *variables.get(&id).unwrap(),
    }
}

fn run_program(stdin: &io::Stdin, calls: &Vec<FunctionBytecode>) {
    let entry_point = {
        let mut result = None;
        for func in calls {
            if func.name.eq("main") {
                result = Some(func);
            } 
        }
        match result {
        Some(r) => r,
        None => {
            println!("Runtime Error. No main function declared.");
            return;
        }
        }
    };
    match run_bytecode(stdin, entry_point, calls, &vec![]) {
    Ok(n) => println!("Run successful. Exit code {}", n),
    Err(e) => println!("{}", e),
    }
}

fn run_bytecode(stdin: &io::Stdin, function: &FunctionBytecode, calls: &Vec<FunctionBytecode>, parameters: &Vec<i32>) -> Result<i32, IRError>  {
    let mut variables: HashMap<i32, i32> = HashMap::new();
    let mut arrays: HashMap<i32, Vec<i32>> = HashMap::new();

    // setup local variables
    for (_, vartype) in &function.variables {
         match vartype {
         VariableType::IntVar(id) => {
             variables.insert(*id, 0);
         }

         VariableType::ArrayVar(id, len) => {
             // create an array of zeroes.
             let arr = vec![0i32; *len as usize];
             arrays.insert(*id, arr);
         }

         }
    }
    if parameters.len() != function.parameters {
         let e = format!("Runtime Error. Incorrect number of parameters passed to the function. Expected {}, got {} parameters", function.parameters, parameters.len());
         return error(MAX_LINE, e);
    }

    // hopefully this covers everything needed for parameter passing...
    for (i, value) in parameters.iter().enumerate() {
        let variable = variables.get_mut(&(i as i32)).unwrap();
        *variable = *value;
    }

    // a lot of unwraps, but we already checked everything
    // so this should work.
    // execute instructions.
    let mut instr_pointer: usize = 0;
    loop {
        let instr = &function.body[instr_pointer];
        match instr {
        Bytecode::End => {
            break;
        }

        Bytecode::Int(id) => {
            let value = variables.get_mut(id).unwrap();
            *value = 0;
            instr_pointer += 1;
        }

        Bytecode::IntArray(id, len) => {
            let array = arrays.get_mut(id).unwrap();
            for i in 0..*len {
                 let idx = i as usize;
                 array[idx] ^= array[idx];
            }
            instr_pointer += 1;
        }

        Bytecode::Out(value) => {
            let num = read_integer_value(&variables, value);
            println!("{}", num);
            instr_pointer += 1;
        }

        Bytecode::In(id) => {
            let mut buf = String::with_capacity(64);
            loop {
                match stdin.read_line(&mut buf) {
                Ok(_) => {
                     let token = buf.trim_end();
                     match token.parse::<i32>() {
                     Ok(num) => {
                          let dest = variables.get_mut(id).unwrap();
                          *dest = num;
                          break;
                     }

                     Err(_) => {
                         println!("User Input Error. '{}' is not a valid number.", token);
                         buf.clear();
                     }

                     }
                }

                Err(e) => {
                     println!("Error. Failed to read from standard input correctly.");
                     println!("{e}");
                     println!("Please try again.");
                }

                }
            }
            instr_pointer += 1;
        }

        Bytecode::Mov(MemWrite::IntVar(dest), src) => {
            let num = read_memory(&variables, &arrays, src)?;
            let dest = variables.get_mut(dest).unwrap();
            *dest = num;
            instr_pointer += 1;
        }

        Bytecode::Mov(MemWrite::ArrayWrite(dest, index), src) => {
            let num = read_memory(&variables, &arrays, src)?;
            let dest = arrays.get_mut(dest).unwrap();
            let index = read_integer_value(&variables, index);
            if index < 0 {
                let e = format!("Runtime Error: Array out of bounds. Value {}. Array Length {}", index, dest.len());
                return error(MAX_LINE, e);
            }
            let i = index as usize;
            if i < dest.len() {
                dest[i] = num;
                instr_pointer += 1;
            } else {
                let e = format!("Runtime Error: Array out of bounds. Value {}. Array Length {}", i, dest.len());
                return error(MAX_LINE, e);
            }
        }

        Bytecode::Add(dest, src1, src2) => {
            let num1 = read_integer_value(&variables, src1);
            let num2 = read_integer_value(&variables, src2);
            let dest = variables.get_mut(dest).unwrap();
            *dest = num1 + num2;
            instr_pointer += 1;
        }

        Bytecode::Sub(dest, src1, src2) => {
            let num1 = read_integer_value(&variables, src1);
            let num2 = read_integer_value(&variables, src2);
            let dest = variables.get_mut(dest).unwrap();
            *dest = num1 - num2;
            instr_pointer += 1;
        }

        Bytecode::Mult(dest, src1, src2) => {
            let num1 = read_integer_value(&variables, src1);
            let num2 = read_integer_value(&variables, src2);
            let dest = variables.get_mut(dest).unwrap();
            *dest = num1 * num2;
            instr_pointer += 1;
        }

        Bytecode::Div(dest, src1, src2) => {
            let num1 = read_integer_value(&variables, src1);
            let num2 = read_integer_value(&variables, src2);
            if num2 == 0 {
                let e = String::from("Error. Attempt to divide by zero.");
                return error(MAX_LINE, e);
            }
            let dest = variables.get_mut(dest).unwrap();
            *dest = num1 / num2;
            instr_pointer += 1;
        }

        Bytecode::Mod(dest, src1, src2) => {
            let num1 = read_integer_value(&variables, src1);
            let num2 = read_integer_value(&variables, src2);
            if num2 == 0 {
                let e = String::from("Error. Attempt to divide by zero.");
                return error(MAX_LINE, e);
            }
            let dest = variables.get_mut(dest).unwrap();
            *dest = num1 % num2;
            instr_pointer += 1;
        }

        Bytecode::LessThan(dest, src1, src2) => {
            let num1 = read_integer_value(&variables, src1);
            let num2 = read_integer_value(&variables, src2);
            let dest = variables.get_mut(dest).unwrap();
            *dest = (num1 < num2) as i32;
            instr_pointer += 1;
        }

        Bytecode::LessEqual(dest, src1, src2) => {
            let num1 = read_integer_value(&variables, src1);
            let num2 = read_integer_value(&variables, src2);
            let dest = variables.get_mut(dest).unwrap();
            *dest = (num1 <= num2) as i32;
            instr_pointer += 1;
        }

        Bytecode::Equal(dest, src1, src2) => {
            let num1 = read_integer_value(&variables, src1);
            let num2 = read_integer_value(&variables, src2);
            let dest = variables.get_mut(dest).unwrap();
            *dest = (num1 == num2) as i32;
            instr_pointer += 1;
        }

        Bytecode::NotEqual(dest, src1, src2) => {
            let num1 = read_integer_value(&variables, src1);
            let num2 = read_integer_value(&variables, src2);
            let dest = variables.get_mut(dest).unwrap();
            *dest = (num1 != num2) as i32;
            instr_pointer += 1;
        }

        Bytecode::GreaterThan(dest, src1, src2) => {
            let num1 = read_integer_value(&variables, src1);
            let num2 = read_integer_value(&variables, src2);
            let dest = variables.get_mut(dest).unwrap();
            *dest = (num1 > num2) as i32;
            instr_pointer += 1;
        }

        Bytecode::GreaterEqual(dest, src1, src2) => {
            let num1 = read_integer_value(&variables, src1);
            let num2 = read_integer_value(&variables, src2);
            let dest = variables.get_mut(dest).unwrap();
            *dest = (num1 >= num2) as i32;
            instr_pointer += 1;
        }

        Bytecode::Label(_) => {
            instr_pointer += 1;
        }

        Bytecode::Jmp(jump) => {
            instr_pointer = *jump;
        }

        Bytecode::BranchIf(src1, jump) => {
            let num1 = read_integer_value(&variables, src1);
            match num1 {
            0 => {instr_pointer += 1;}
            1 => {instr_pointer = *jump;}
            _ => {
                let e = format!("Runtime Error. Branch on a variable that is neither 0 or 1. The value is: {}", num1);
                return error(MAX_LINE, e);
            }
            }
        }

        Bytecode::BranchIfn(src1, jump) => {
            let num1 = read_integer_value(&variables, src1);
            match num1 {
            0 => {instr_pointer = *jump;}
            1 => {instr_pointer += 1;}
            _ => {
                let e = format!("Runtime Error. Branch on a variable that is neither 0 or 1. The value is: {}", num1);
                return error(MAX_LINE, e);
            }
            }
        }

        Bytecode::Call(dest, function_index, parameters) => {
             let function = &calls[*function_index];
             let mut pass = vec![];
             for p in parameters {
                  let num1: i32 = read_integer_value(&variables, p);
                  pass.push(num1);
             }

             let eax = run_bytecode(stdin, function, calls, &pass)?;
             let dest = variables.get_mut(dest).unwrap();
             *dest = eax;
             instr_pointer += 1;
        }

        Bytecode::Return(src1) => {
            let num = read_integer_value(&variables, src1);
            return Ok(num);
        }

        }
    }

    return Ok(0);
}

fn lookup_integer_variable_id(line: usize, function: &FunctionBytecode, ident: &String) -> Result<Op, IRError> {
    if let Some(id) = function.variables.get(ident) {
         match id {
         VariableType::IntVar(id) => Ok(Op::Var(*id)),

         VariableType::ArrayVar(_,_) => {
             let f = format!("invalid operand. '{}' is an array, not an integer.", ident);
             return error(line, f);
         }

         }
    } else {
         let f = format!("invalid instruction. identifier '{}' has not been declared.", ident);
         return error(line, f);
    }
}

fn lookup_variable_dest_id(line: usize, function: &FunctionBytecode, ident: &String) -> Result<i32, IRError> {
    if let Some(id) = function.variables.get(ident) {
         match id {
         VariableType::IntVar(id) => Ok(*id),

         VariableType::ArrayVar(_,_) => {
             let f = format!("invalid operand. '{}' is an array, not an integer.", ident);
             return error(line, f);
         }

         }
    } else {
         let f = format!("invalid instruction. identifier '{}' has not been declared.", ident);
         return error(line, f);
    }
}

fn parse_instruction(serialized_line: &mut usize, line: usize, function: &mut FunctionBytecode, labels_hash: &mut HashMap<String, usize>, tokens: &Vec<IRTok>, idx: &mut usize) -> Result<Bytecode, IRError> {

    // get rid of newlines.
    loop {
        if matches!(peek_result(*serialized_line, tokens, *idx)?, IRTok::EndInstr) {
            *serialized_line += 1;
            *idx += 1;
        } else {
            break;
        }
    }

    let bytecode: Bytecode;
    let opcode = peek_result(*serialized_line, tokens, *idx)?;
    match opcode {

    // declarations.
    IRTok::Int => {
        *idx += 1;
        let ident = match next_result(*serialized_line, tokens, idx)? {
        IRTok::Var(ident) => ident,
        _ => return error(*serialized_line, String::from("invalid instruction. expected identifier like '%int variable'")),
        };

        if let Some(_) = function.variables.get(ident) {
             let f = format!("invalid instruction. identifier '{}' declared too many times", ident);
             return error(*serialized_line, f);
        } else {
             let id = get_id(function);
             function.variables.insert(ident.clone(), VariableType::IntVar(id));
             bytecode = Bytecode::Int(id);
        }
    }

    IRTok::IntArray => {
        *idx += 1;
        let ident = match next_result(*serialized_line, tokens, idx)? {
        IRTok::Var(ident) => ident,
        _ => return error(*serialized_line, String::from("invalid instruction. expected format like '%int[] array, 10'")),
        };

        if !matches!(next_result(*serialized_line, tokens, idx)?, IRTok::Comma) {
            return error(*serialized_line, String::from("invalid instruction. expected format like '%int[] array, 10'"));
        }

        let num = match next_result(*serialized_line, tokens, idx)? {
        IRTok::Num(num) => *num,
        IRTok::Var(ident) => {
          return error(*serialized_line, format!("array cannot be a variable '{ident}' length. must be a number."));
        }
        _ => {return error(*serialized_line, String::from("invalid instruction. expected format like '%int[] array, 10'"));}
        };

        if num <= 0 {
          return error(*serialized_line, String::from("array size cannot be less than or equal to zero."));
        }

        if let Some(_) = function.variables.get(ident) {
             let f = format!("invalid instruction. identifier '{}' declared too many times", ident);
             return error(*serialized_line, f);
        } else {
             let id = get_id(function);
             function.variables.insert(ident.clone(), VariableType::ArrayVar(id, num));
             bytecode = Bytecode::IntArray(id, num);
        }
    }

    // function calling routines.
    IRTok::Call => {
        *idx += 1;
        let op = match next_result(*serialized_line, tokens, idx)? {
        IRTok::Var(ident) => lookup_variable_dest_id(*serialized_line, function, ident)?,
        _ => return error(*serialized_line, String::from("invalid instruction. expected format like '%call value, function(a,b)'")),
        };

        if !matches!(next_result(*serialized_line, tokens, idx)?, IRTok::Comma) {
            return error(*serialized_line, String::from("invalid instruction. missing comma ',' in between '%call value, function(a,b)'"));
        }

        let func_id = match peek_result(*serialized_line, tokens, *idx)? {
        IRTok::Var(_) => {
            let func_id = *idx;
            *idx += 1;
            func_id 
        }
        _ => return error(*serialized_line, String::from("invalid instruction. expected function name from '%call value, function(a,b)'")),
        };

        if !matches!(next_result(*serialized_line, tokens, idx)?, IRTok::LParen) {
            return error(*serialized_line, String::from("invalid instruction. expected '(' in between '%call value, function(a,b)'"));
        }

        let mut parameters = vec![];
        loop {
            match peek_result(*serialized_line, tokens, *idx)? {
            IRTok::RParen => break,
            IRTok::Var(ident) => {
                *idx += 1;
                let param = lookup_integer_variable_id(*serialized_line, function, ident)?;
                parameters.push(param);
                if matches!(peek_result(*serialized_line, tokens, *idx)?, IRTok::Comma) {
                    *idx += 1;
                }
            }

            IRTok::Num(num) => {
                *idx += 1;
                parameters.push(Op::Num(*num));
                if matches!(peek_result(*serialized_line, tokens, *idx)?, IRTok::Comma) {
                    *idx += 1;
                }
            }
            _ => return error(*serialized_line, String::from("invalid calling convention. must be in the format '%call value, function(a,b)'")),

            }
        }

        if !matches!(next_result(*serialized_line, tokens, idx)?, IRTok::RParen) {
            return error(*serialized_line, String::from("invalid instruction. missing ')' in between '%call value, function(a,b)'"));
        }
        bytecode = Bytecode::Call(op, func_id, parameters);
    }

    IRTok::Return => {
        *idx += 1;
        let op = match next_result(*serialized_line, tokens, idx)? {
        IRTok::Var(ident) => lookup_integer_variable_id(*serialized_line, function, ident)?,
        IRTok::Num(num) => Op::Num(*num),
        _ => return error(*serialized_line, String::from("invalid instruction. expected format like '%ret variable'")),
        };
        bytecode = Bytecode::Return(op);
    }

    // input/output routines.
    IRTok::Out => {
        *idx += 1;
        let src = match next_result(*serialized_line, tokens, idx)? {
        IRTok::Var(ident) => lookup_integer_variable_id(*serialized_line, function, ident)?,
        IRTok::Num(num) => Op::Num(*num),
        _ => return error(*serialized_line, String::from("invalid instruction. expected format like '%out variable'")),
        };
        bytecode = Bytecode::Out(src);
    }

    IRTok::In => {
        *idx += 1;
        let src = match next_result(*serialized_line, tokens, idx)? {
        IRTok::Var(ident) => lookup_variable_dest_id(*serialized_line, function, ident)?,
        _ => return error(*serialized_line, String::from("invalid instruction. expected format like '%input variable'")),
        };
        bytecode = Bytecode::In(src);
    }

    // mathematical operators.
    IRTok::Mov => {
        *idx += 1;
        match next_result(*serialized_line, tokens, idx)? {
        IRTok::Var(ident) => {
            let dest = lookup_variable_dest_id(*serialized_line, function, ident)?;

            if !matches!(next_result(*serialized_line, tokens, idx)?, IRTok::Comma) {
                return error(*serialized_line, String::from("invalid instruction. missing comma. expected format like '%mov variable, 10'"));
            }
            
            let src = match next_result(*serialized_line, tokens, idx)? {
            IRTok::Var(ident) => {
                if let Some(id) = function.variables.get(ident) {
                     match id {
                     VariableType::IntVar(id) => MemRead::IntVar(*id),
         
                     VariableType::ArrayVar(_,_) => {
                         let f = format!("invalid '%mov' statement. {} is an array, not an integer.", ident);
                         return error(*serialized_line, f);
                     }
         
                     }
                } else {
                     let f = format!("invalid instruction. identifier '{}' has not been declared", ident);
                     return error(*serialized_line, f);
                }
            }

            IRTok::LBrace => {
                match (next_result(*serialized_line, tokens,idx)?, next_result(*serialized_line, tokens,idx)?, next_result(*serialized_line, tokens,idx)?, next_result(*serialized_line, tokens,idx)?) {
                (IRTok::Var(array), IRTok::Plus, IRTok::Num(index), IRTok::RBrace) => {
                    if let Some(id) = function.variables.get(array) {
                        match id {
                        VariableType::ArrayVar(id,_) => {
                            MemRead::ArrayRead(*id, Op::Num(*index))
                        }
                        _ => {
                           let f = format!("invalid '%mov' statement. {} is an integer, not an array.", array);
                           return error(*serialized_line, f);
                        }

                        }
                    } else {
                        let f = format!("invalid instruction. no such identifier '{}'.", array);
                        return error(*serialized_line, f);
                    }
                }

                (IRTok::Var(array), IRTok::Plus, IRTok::Var(variable), IRTok::RBrace) => {
                    if let Some(id) = function.variables.get(array) {
                        match id {
                        VariableType::ArrayVar(id,_) => {
                            
                            MemRead::ArrayRead(*id, lookup_integer_variable_id(*serialized_line, function, variable)?)
                        }
                        _ => {
                           let f = format!("invalid '%mov' statement. {} is an integer, not an array.", array);
                           return error(*serialized_line, f);
                        }

                        }
                    } else {
                        let f = format!("invalid instruction. no such identifier '{}'.", array);
                        return error(*serialized_line, f);
                    }
                }

                _ => return error(*serialized_line, String::from("invalid '%mov' statement. expected '%mov var, [array + index]'")),

                }

            }

            IRTok::Num(num) => MemRead::Number(*num),
            _ => return error(*serialized_line, String::from("invalid instruction. expected format like '%mov variable, 10'")),
            };

            bytecode = Bytecode::Mov(MemWrite::IntVar(dest), src);
        }

        IRTok::LBrace => {
            let dest = match next_result(*serialized_line, tokens, idx)? {
            IRTok::Var(ident) => {
                if let Some(id) = function.variables.get(ident) {
                    match id {
                    VariableType::IntVar(_) => {
                        let f = format!("invalid '%mov' statement. {} is an array, not an integer.", ident);
                        return error(*serialized_line, f);
                    }
         
                    VariableType::ArrayVar(dest,_) => {
                        *dest
                    }

                    }
                } else {
                    return error(*serialized_line, String::from("invalid instruction. expected format like '%mov [array + 10], 10'"));
                }
            }

            _ => return error(*serialized_line, String::from("invalid instruction. expected format like '%mov [array + 10], 10'")),
            };

            if !matches!(next_result(*serialized_line, tokens, idx)?, IRTok::Plus) {
                return error(*serialized_line, String::from("invalid instruction. expected format like '%mov [array + 10], 10'"));
            }

            let index = match next_result(*serialized_line, tokens, idx)? {
            IRTok::Var(id) => lookup_integer_variable_id(*serialized_line, function, id)?,
            IRTok::Num(num) => Op::Num(*num),
            _ => return error(*serialized_line, String::from("invalid instruction. expected format like '%mov [array + 10], 10'")),
            };

            if !matches!(next_result(*serialized_line, tokens, idx)?, IRTok::RBrace) {
                return error(*serialized_line, String::from("invalid instruction. expected format like '%mov [array + 10], 10'"));
            }

            if !matches!(next_result(*serialized_line, tokens, idx)?, IRTok::Comma) {
                return error(*serialized_line, String::from("invalid instruction. expected format like '%mov [array + 10], 10'"));
            }

            let src = match next_result(*serialized_line, tokens, idx)? {
            IRTok::Var(ident) => {
                if let Some(id) = function.variables.get(ident) {
                     match id {
                     VariableType::IntVar(id) => MemRead::IntVar(*id),
         
                     VariableType::ArrayVar(_,_) => {
                         let f = format!("invalid '%mov' statement. {} is an array, not an integer.", ident);
                         return error(*serialized_line, f);
                     }
         
                     }
                } else {
                     let f = format!("invalid instruction. identifier '{}' has not been defined.", ident);
                     return error(*serialized_line, f);
                }
            }

            IRTok::Num(num) => MemRead::Number(*num),
            _ => return error(*serialized_line, String::from("invalid instruction. expected format like '%mov variable, 10'")),
            };

            bytecode = Bytecode::Mov(MemWrite::ArrayWrite(dest, index), src);
        }

        _ => return error(*serialized_line, String::from("invalid instruction. expected format like '%mov variable, 10'")),
        }
 
    }

    IRTok::Add => {
        *idx += 1;
        let (dest, src1, src2) = addr_code3(*serialized_line, function, tokens, idx)?;
        bytecode = Bytecode::Add(dest, src1, src2);
    }

    IRTok::Sub => {
        *idx += 1;
        let (dest, src1, src2) = addr_code3(*serialized_line, function, tokens, idx)?;
        bytecode = Bytecode::Sub(dest, src1, src2);
    }

    IRTok::Mult => {
        *idx += 1;
        let (dest, src1, src2) = addr_code3(*serialized_line, function, tokens, idx)?;
        bytecode = Bytecode::Mult(dest, src1, src2);
    }

    IRTok::Div => {
        *idx += 1;
        let (dest, src1, src2) = addr_code3(*serialized_line, function, tokens, idx)?;
        bytecode = Bytecode::Div(dest, src1, src2);
    }

    IRTok::Mod => {
        *idx += 1;
        let (dest, src1, src2) = addr_code3(*serialized_line, function, tokens, idx)?;
        bytecode = Bytecode::Mod(dest, src1, src2);
    }

    // comparison operators.
    IRTok::LessThan => {
        *idx += 1;
        let (dest, src1, src2) = addr_code3(*serialized_line, function, tokens, idx)?;
        bytecode = Bytecode::LessThan(dest, src1, src2);
    }

    IRTok::LessEqual => {
        *idx += 1;
        let (dest, src1, src2) = addr_code3(*serialized_line, function, tokens, idx)?;
        bytecode = Bytecode::LessEqual(dest, src1, src2);
    }

    IRTok::NotEqual => {
        *idx += 1;
        let (dest, src1, src2) = addr_code3(*serialized_line, function, tokens, idx)?;
        bytecode = Bytecode::NotEqual(dest, src1, src2);
    }

    IRTok::Equal => {
        *idx += 1;
        let (dest, src1, src2) = addr_code3(*serialized_line, function, tokens, idx)?;
        bytecode = Bytecode::Equal(dest, src1, src2);
    }

    IRTok::GreaterEqual => {
        *idx += 1;
        let (dest, src1, src2) = addr_code3(*serialized_line, function, tokens, idx)?;
        bytecode = Bytecode::GreaterEqual(dest, src1, src2);
    }

    IRTok::GreaterThan => {
        *idx += 1;
        let (dest, src1, src2) = addr_code3(*serialized_line, function, tokens, idx)?;
        bytecode = Bytecode::GreaterThan(dest, src1, src2);
    }

    // labels/branching
    //Label,
    IRTok::Jump => {
        *idx += 1;
        match peek_result(*serialized_line, tokens, *idx)? {
        IRTok::Label(_) => {
            bytecode = Bytecode::Jmp(*idx);
            *idx += 1;
        }

        _ => return error(*serialized_line, String::from("%jmp requires a label such as '%jmp :label'")),
        }
    }

    IRTok::Label(name) => {
        *idx += 1;
        if let None = labels_hash.get(name) {
            labels_hash.insert(name.clone(), line);
        } else {
            return error(*serialized_line, format!("label {} already defined.", name));
        }
        bytecode = Bytecode::Label(line);
        if !matches!(peek_result(*serialized_line, tokens, *idx)?, IRTok::EndInstr) {
            return error(*serialized_line, format!("invalid opcode '{}'. labels can be declared using ':label'", name));
        }
    }

    IRTok::BranchIf => {
        *idx += 1;
        let dest = match next_result(*serialized_line, tokens, idx)? {
        IRTok::Var(ident) => lookup_integer_variable_id(*serialized_line, function, ident)?,
        IRTok::Num(num) => Op::Num(*num),
        _ => return error(*serialized_line, String::from("%branch_if requires an identifier 'TF'")),
        };

        if !matches!(next_result(*serialized_line, tokens, idx)?, IRTok::Comma) {
            return error(*serialized_line, String::from("missing comma ',' from %branch_if instruction."));
        }

        match peek_result(*serialized_line, tokens, *idx)? {
        IRTok::Label(_) => {
            bytecode = Bytecode::BranchIf(dest, *idx);
            *idx += 1;
        }
        _ => return error(*serialized_line, String::from("%branch_if requires a label ':label'. (e.g. '%branch_if TF, :label')")),
        }
    }

    IRTok::BranchIfNot => {
        *idx += 1;
        let dest = match next_result(*serialized_line, tokens, idx)? {
        IRTok::Var(ident) => lookup_integer_variable_id(*serialized_line, function, ident)?,
        IRTok::Num(num) => Op::Num(*num),
        _ => return error(*serialized_line, String::from("%branch_ifn requires an identifier 'TF'")),
        };

        if !matches!(next_result(*serialized_line, tokens, idx)?, IRTok::Comma) {
            return error(*serialized_line, String::from("missing ',' from %branch_ifn instruction."));
        }

        match peek_result(*serialized_line, tokens, *idx)? {
        IRTok::Label(_) => {
            bytecode = Bytecode::BranchIfn(dest, *idx);
            *idx += 1;
        }
        _ => return error(*serialized_line, String::from("%branch_ifn requires a label ':label'. (e.g. '%branch_ifn TF, :label')")),
        }
    }

    IRTok::EndFunc => {
        bytecode = Bytecode::End;
        return Ok(bytecode);
    }

    IRTok::InvalidInstruction(err) => {
        return error(*serialized_line, format!("invalid instruction opcode '{err}'. instructions must begin with an opcode such as %mov, %add, %sub"));
    }

    _ => {
        return error(*serialized_line, String::from("invalid instruction. instructions must begin with an opcode such as %mov, %add, %sub"));
    }

    }

    if !matches!(next_result(*serialized_line, tokens, idx)?, IRTok::EndInstr) {
        return error(*serialized_line, String::from("expected newline."));
    }

    *serialized_line += 1;

    return Ok(bytecode);
}

fn addr_code3(serialized_line: usize, function: &FunctionBytecode, tokens: &Vec<IRTok>, idx: &mut usize) -> Result<(i32, Op, Op), IRError> {
    let dest = match next_result(serialized_line, tokens, idx)? {
    IRTok::Var(ident) => lookup_variable_dest_id(serialized_line, function, ident)?,
    _ => return error(serialized_line, String::from("invalid dest.")),
    };

    if !matches!(next_result(serialized_line, tokens, idx)?, IRTok::Comma) {
        return error(serialized_line, String::from("invalid instruction. expected comma between dest and src1."));
    }
    
    let src1 = match next_result(serialized_line, tokens, idx)? {
    IRTok::Var(ident) => lookup_integer_variable_id(serialized_line, function, ident)?,
    IRTok::Num(num) => Op::Num(*num),
    _ => return error(serialized_line, String::from("invalid src1.")),
    };

    if !matches!(next_result(serialized_line, tokens, idx)?, IRTok::Comma) {
        return error(serialized_line, String::from("invalid instruction. expected comma between src1 and src2."));
    }

    let src2 = match next_result(serialized_line, tokens, idx)? {
    IRTok::Var(ident) => lookup_integer_variable_id(serialized_line, function, ident)?,
    IRTok::Num(num) => Op::Num(*num),
    _ => return error(serialized_line, String::from("invalid src2.")),
    };

    return Ok((dest, src1, src2));
}

fn next<'a>(tokens: &'a Vec<IRTok>, index: &mut usize) -> Option<&'a IRTok> {
    if *index < tokens.len() {
        let ret = *index;
        *index += 1;
        return Some(&tokens[ret])
    } else {
        return None
    }
}

fn peek_result<'a>(serialized_line: usize, tokens: &'a Vec<IRTok>, index: usize) -> Result<&'a IRTok, IRError> {
    if index < tokens.len() {
        return Ok(&tokens[index]);
    } else {
        return error(serialized_line, String::from("unexpected end."));
    }
}

fn peek<'a>(tokens: &'a Vec<IRTok>, index: usize) -> Option<&'a IRTok>{
    if index < tokens.len() {
        return Some(&tokens[index])
    } else {
        return None
    }
}

fn next_result<'a>(serialized_line: usize, tokens: &'a Vec<IRTok>, index: &mut usize) -> Result<&'a IRTok, IRError> {
    if *index < tokens.len() {
        let ret = *index;
        *index += 1;
        return Ok(&tokens[ret])
    } else {
        return error(serialized_line, String::from("unexpected end."))
    }
}

fn lex_ir_token(mut code: &str) -> (Option<IRTok>, &str) {
   
    #[derive(Debug)]
    enum StateMachine {
        Initial,
        Lit,
        Label,
        Ident,
        Num,
        Comments,
    }

    fn opcode(s: &str) -> Option<IRTok> {
        use IRTok::*;
        match s {
        "%func" => Some(Func),
        "%endfunc" => Some(EndFunc),
        "%int" => Some(Int),
        "%int[]" => Some(IntArray),
        "%call" => Some(Call),
        "%ret" => Some(Return),
        "%out" => Some(Out),
        "%input" => Some(In),
        "%mov" => Some(Mov),
        "%add" => Some(Add),
        "%sub" => Some(Sub),
        "%mult" => Some(Mult),
        "%div" => Some(Div),
        "%mod" => Some(Mod),
        "%lt" => Some(LessThan),
        "%le" => Some(LessEqual),
        "%neq" => Some(NotEqual),
        "%eq" => Some(Equal),
        "%gt" => Some(GreaterThan),
        "%ge" => Some(GreaterEqual),
        "%jmp" => Some(Jump),
        "%branch_if" => Some(BranchIf),
        "%branch_ifn" => Some(BranchIfNot),
        _ => Some(InvalidInstruction(String::from(s))),
        }
    }

    fn num_literal(s: &str) -> Option<IRTok> {
        match s.parse::<i32>() {
        Ok(val) => Some(IRTok::Num(val)),
        Err(_) => None,
        }
    }

    // skip left whitespace.
    for (i, c) in code.chars().enumerate() {
        if c.is_whitespace() && c != '\n' {
            continue;
        }
        code = &code[i..];
        break;
    }
 
    let mut state = StateMachine::Initial;

    for (i, c) in code.chars().enumerate() {
        state = match state {

        StateMachine::Initial => {
            if c == '\n' {
                return (Some(IRTok::EndInstr), &code[i + 1..]);
            }
            if c.is_whitespace() {
                continue;
            }
            match c {
            '%' => StateMachine::Lit,
            ':' => StateMachine::Label,
            ',' => return (Some(IRTok::Comma), &code[i + 1..]),
            '[' => return (Some(IRTok::LBrace), &code[i + 1..]),
            '(' => return (Some(IRTok::LParen), &code[i + 1..]),
            ')' => return (Some(IRTok::RParen), &code[i + 1..]),
            '+' => return (Some(IRTok::Plus), &code[i + 1..]),
            ']' => return (Some(IRTok::RBrace), &code[i + 1..]),
            '0'..='9' => StateMachine::Num,
            ';' => StateMachine::Comments,
            _ => StateMachine::Ident,
            }
        }

        StateMachine::Lit => {
            if c == ',' || c == '\n' || c == ';' {
                let tok = opcode(&code[..i]);
                return (tok, &code[i..]);
            }
            if c.is_whitespace() {
                let tok = opcode(&code[..i]);
                return (tok, &code[i+1..]);
            }

            StateMachine::Lit
        }

        StateMachine::Label => {
            if c == ',' || c == '\n' || c == ';' {
                let tok = &code[..i];
                return (Some(IRTok::Label(String::from(tok))), &code[i..]);
            }
            if c.is_whitespace() {
                let tok = &code[..i];
                return (Some(IRTok::Label(String::from(tok))), &code[i+1..]);
            }

            StateMachine::Label
        }

        StateMachine::Comments => {
            if c == '\n' {
                return (Some(IRTok::EndInstr), &code[i + 1..]);
            } else {
                StateMachine::Comments
            }
        }

        StateMachine::Ident => {
            if c == ',' || c == '\n' || c == '[' || c == ']' || c == ';' || c == '+' || c == '(' || c == ')' {
                let tok = IRTok::Var(String::from(&code[..i]));
                return (Some(tok), &code[i..]);
            }

            if c.is_whitespace() {
                let tok = IRTok::Var(String::from(&code[..i]));
                return (Some(tok), &code[i+1..]);
            }

            StateMachine::Ident
        }

        StateMachine::Num => {
            if c >= '0' && c <= '9' {
                StateMachine::Num
            } else {
                let tok = num_literal(&code[..i]);
                return (tok, &code[i..]);
            }

        }
        
        };
    }

    match state {

    StateMachine::Lit => {
        return (opcode(code), "");
    }

    StateMachine::Ident => {
        let tok = IRTok::Var(String::from(code));
        return (Some(tok), "");
    }


    _ => {
        println!("{:?} {}", state, code);
        todo!()
    }

    }
}

#[cfg(test)]
mod ir_tests {
    use crate::interpreter::*;

    #[test]
    fn ir_token() {
        assert!(matches!(lex_ir_token("  %int"), (Some(IRTok::Int), _)));
        assert!(matches!(lex_ir_token(" %int[]"), (Some(IRTok::IntArray), _)));
        assert!(matches!(lex_ir_token("%call"), (Some(IRTok::Call), _)));
        assert!(matches!(lex_ir_token("%ret"), (Some(IRTok::Return), _)));
        assert!(matches!(lex_ir_token("%out"), (Some(IRTok::Out), _)));
        assert!(matches!(lex_ir_token("   %input"), (Some(IRTok::In), _)));
        assert!(matches!(lex_ir_token("%mov  "), (Some(IRTok::Mov), _)));
        assert!(matches!(lex_ir_token("%add"), (Some(IRTok::Add), _)));
        assert!(matches!(lex_ir_token("%sub"), (Some(IRTok::Sub), _)));
        assert!(matches!(lex_ir_token("%mult"), (Some(IRTok::Mult), _)));
        assert!(matches!(lex_ir_token("  %div"), (Some(IRTok::Div), _)));
        assert!(matches!(lex_ir_token("%mod"), (Some(IRTok::Mod), _)));
        assert!(matches!(lex_ir_token("%lt"), (Some(IRTok::LessThan), _)));
        assert!(matches!(lex_ir_token("%le"), (Some(IRTok::LessEqual), _)));
        assert!(matches!(lex_ir_token("%neq"), (Some(IRTok::NotEqual), _)));
        assert!(matches!(lex_ir_token("%eq"), (Some(IRTok::Equal), _)));
        assert!(matches!(lex_ir_token("%gt"), (Some(IRTok::GreaterThan), _)));
        assert!(matches!(lex_ir_token("%ge"), (Some(IRTok::GreaterEqual), _)));
        assert!(matches!(lex_ir_token("%jmp"), (Some(IRTok::Jump), _)));
        assert!(matches!(lex_ir_token("%branch_if"), (Some(IRTok::BranchIf), _)));
        assert!(matches!(lex_ir_token("%branch_ifn"), (Some(IRTok::BranchIfNot), _)));
        assert!(matches!(lex_ir_token("[are"), (Some(IRTok::LBrace), "are")));
        assert!(matches!(lex_ir_token("]are"), (Some(IRTok::RBrace), "are")));
        assert!(matches!(lex_ir_token(",are"), (Some(IRTok::Comma), "are")));

        let code = "; This is a comment\n%mov";
        assert!(matches!(lex_ir_token(code), (Some(IRTok::EndInstr), "%mov")));
    }

    #[test]
    fn ir_lex() {
        {
            let toks = lex_ir("%add a, b, c\n");
            assert!(toks.len() == 7);
            assert!(matches!(toks[0], IRTok::Add));
            assert!(matches!(toks[1], IRTok::Var(_)));
            assert!(matches!(toks[2], IRTok::Comma));
            assert!(matches!(toks[3], IRTok::Var(_)));
            assert!(matches!(toks[4], IRTok::Comma));
            assert!(matches!(toks[5], IRTok::Var(_)));
            assert!(matches!(toks[6], IRTok::EndInstr));
        }

        {
            let toks = lex_ir("%func main,,,\n");
            assert!(toks.len() == 6);
            assert!(matches!(toks[0], IRTok::Func));
            assert!(matches!(toks[1], IRTok::Var(_)));
            assert!(matches!(toks[2], IRTok::Comma));
            assert!(matches!(toks[3], IRTok::Comma));
            assert!(matches!(toks[4], IRTok::Comma));
            assert!(matches!(toks[5], IRTok::EndInstr));
        }

        {
            let toks = lex_ir("%func,main,,,\n");
            assert!(toks.len() == 7);
            assert!(matches!(toks[0], IRTok::Func));
            assert!(matches!(toks[1], IRTok::Comma));
            assert!(matches!(toks[2], IRTok::Var(_)));
            assert!(matches!(toks[3], IRTok::Comma));
            assert!(matches!(toks[4], IRTok::Comma));
            assert!(matches!(toks[5], IRTok::Comma));
            assert!(matches!(toks[6], IRTok::EndInstr));
        }

        {
            let toks = lex_ir("%mov [arr+0], 100\n");
            assert!(toks.len() == 9);
            assert!(matches!(toks[0], IRTok::Mov));
            assert!(matches!(toks[1], IRTok::LBrace));
            assert!(matches!(toks[2], IRTok::Var(_)));
            assert!(matches!(toks[3], IRTok::Plus));
            assert!(matches!(toks[4], IRTok::Num(0)));
            assert!(matches!(toks[5], IRTok::RBrace));
            assert!(matches!(toks[6], IRTok::Comma));
            assert!(matches!(toks[7], IRTok::Num(100)));
            assert!(matches!(toks[8], IRTok::EndInstr));
        }
    }
}


#[derive(Debug)]
enum IRTok {
    // func
    Func,
    EndFunc,

    // declarations.
    Int,
    IntArray,

    // function calling routines.
    Call,
    Return,

    // input/output routines.
    Out,
    In,

    // mathematical operators.
    Mov,
    Add,
    Sub,
    Mult,
    Div,
    Mod,

    // comparison operators.
    LessThan,
    LessEqual,
    NotEqual,
    Equal,
    GreaterEqual,
    GreaterThan,

    // labels/branching
    Label(String),
    Jump,
    BranchIf,
    BranchIfNot,

    Comma,
    LBrace,
    RBrace,
    LParen,
    RParen,
    Plus,

    EndInstr,

    InvalidInstruction(String),

    Num(i32),
    Var(String),
}

#[derive(Debug, Clone)]
enum Op {
    Num(i32),
    Var(i32),
}

#[derive(Debug)]
enum VariableType {
    IntVar(i32),
    ArrayVar(i32, i32),
}

#[derive(Debug)]
enum MemWrite {
    IntVar(i32),
    ArrayWrite(i32, Op),
}

#[derive(Debug)]
enum MemRead {
    IntVar(i32),
    Number(i32),
    ArrayRead(i32, Op),
}

// TODO: array bounds check.
fn read_memory(variables: &HashMap<i32, i32>, arrays: &HashMap<i32, Vec<i32>>, read: &MemRead) -> Result<i32, IRError> {
    match read {
    MemRead::IntVar(id) => Ok(*variables.get(&id).unwrap()),
    MemRead::Number(number) => Ok(*number),
    MemRead::ArrayRead(id, index) => {
        let array = arrays.get(&id).unwrap();
        let variable = read_integer_value(&variables, &index);
        if variable >= 0 && (variable as usize) < array.len() {
            Ok(array[variable as usize])
        } else {
            error(MAX_LINE, format!("Runtime Error: Array out of bounds. Index {}. Array Length {}.", variable, array.len()))
        }
    }
    }
}


#[derive(Debug)]
enum Bytecode {

    // EndFunc
    End,
    Label(usize),

    // declarations.
    Int(i32),
    IntArray(i32, i32),

    // input/output routines.
    Out(Op),
    In(i32),

    // mathematical operators.
    Mov(MemWrite, MemRead),
    Add(i32, Op, Op),
    Sub(i32, Op, Op),
    Mult(i32, Op, Op),
    Div(i32, Op, Op),
    Mod(i32, Op, Op),

    // calling functions.
    Call(i32, usize, Vec<Op>),

    // comparison operators.
    LessThan(i32, Op, Op),
    LessEqual(i32, Op, Op),
    NotEqual(i32, Op, Op),
    Equal(i32, Op, Op),
    GreaterEqual(i32, Op, Op),
    GreaterThan(i32, Op, Op),
    Return(Op),
    Jmp(usize),
    BranchIf(Op, usize),
    BranchIfn(Op, usize),
}


